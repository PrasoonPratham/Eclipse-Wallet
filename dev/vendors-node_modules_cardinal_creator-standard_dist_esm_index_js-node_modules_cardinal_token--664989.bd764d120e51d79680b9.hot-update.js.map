{"version":3,"file":"vendors-node_modules_cardinal_creator-standard_dist_esm_index_js-node_modules_cardinal_token--664989.bd764d120e51d79680b9.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@coral-xyz/app-extension/../../node_modules/ethereum-multicall/dist/esm/multicall.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { BigNumber, ethers } from 'ethers';\nimport { defaultAbiCoder } from 'ethers/lib/utils';\nimport { ExecutionType, Networks } from './enums';\nimport { Utils } from './utils';\nvar Multicall = /** @class */ (function () {\n    function Multicall(_options) {\n        this._options = _options;\n        if (this._options.web3Instance) {\n            this._executionType = ExecutionType.web3;\n            return;\n        }\n        if (this._options.ethersProvider) {\n            this._executionType = ExecutionType.ethers;\n            return;\n        }\n        if (this._options.nodeUrl) {\n            this._executionType = ExecutionType.customHttp;\n            return;\n        }\n        throw new Error(\n        // tslint:disable-next-line: max-line-length\n        'Your options passed in our incorrect they need to match either `MulticallOptionsEthers`, `MulticallOptionsWeb3` or `MulticallOptionsCustomJsonRpcProvider` interfaces');\n    }\n    /**\n     * Call all the contract calls in 1\n     * @param calls The calls\n     */\n    Multicall.prototype.call = function (contractCallContexts, contractCallOptions) {\n        if (contractCallOptions === void 0) { contractCallOptions = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            var aggregateResponse, returnObject, response, contractCallsResults, originalContractCallContext, returnObjectResult, method, methodContext, originalContractCallMethodContext, outputTypes, decodedReturnValues;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!Array.isArray(contractCallContexts)) {\n                            contractCallContexts = [contractCallContexts];\n                        }\n                        return [4 /*yield*/, this.execute(this.buildAggregateCallContext(contractCallContexts), contractCallOptions)];\n                    case 1:\n                        aggregateResponse = _a.sent();\n                        returnObject = {\n                            results: {},\n                            blockNumber: aggregateResponse.blockNumber,\n                        };\n                        for (response = 0; response < aggregateResponse.results.length; response++) {\n                            contractCallsResults = aggregateResponse.results[response];\n                            originalContractCallContext = contractCallContexts[contractCallsResults.contractContextIndex];\n                            returnObjectResult = {\n                                originalContractCallContext: Utils.deepClone(originalContractCallContext),\n                                callsReturnContext: [],\n                            };\n                            for (method = 0; method < contractCallsResults.methodResults.length; method++) {\n                                methodContext = contractCallsResults.methodResults[method];\n                                originalContractCallMethodContext = originalContractCallContext.calls[methodContext.contractMethodIndex];\n                                outputTypes = this.findOutputTypesFromAbi(originalContractCallContext.abi, originalContractCallMethodContext.methodName);\n                                if (this._options.tryAggregate && !methodContext.result.success) {\n                                    returnObjectResult.callsReturnContext.push(Utils.deepClone({\n                                        returnValues: [],\n                                        decoded: false,\n                                        reference: originalContractCallMethodContext.reference,\n                                        methodName: originalContractCallMethodContext.methodName,\n                                        methodParameters: originalContractCallMethodContext.methodParameters,\n                                        success: false,\n                                    }));\n                                    continue;\n                                }\n                                if (outputTypes && outputTypes.length > 0) {\n                                    try {\n                                        decodedReturnValues = defaultAbiCoder.decode(\n                                        // tslint:disable-next-line: no-any\n                                        outputTypes, this.getReturnDataFromResult(methodContext.result));\n                                        returnObjectResult.callsReturnContext.push(Utils.deepClone({\n                                            returnValues: this.formatReturnValues(decodedReturnValues),\n                                            decoded: true,\n                                            reference: originalContractCallMethodContext.reference,\n                                            methodName: originalContractCallMethodContext.methodName,\n                                            methodParameters: originalContractCallMethodContext.methodParameters,\n                                            success: true,\n                                        }));\n                                    }\n                                    catch (e) {\n                                        if (!this._options.tryAggregate) {\n                                            throw e;\n                                        }\n                                        returnObjectResult.callsReturnContext.push(Utils.deepClone({\n                                            returnValues: [],\n                                            decoded: false,\n                                            reference: originalContractCallMethodContext.reference,\n                                            methodName: originalContractCallMethodContext.methodName,\n                                            methodParameters: originalContractCallMethodContext.methodParameters,\n                                            success: false,\n                                        }));\n                                    }\n                                }\n                                else {\n                                    returnObjectResult.callsReturnContext.push(Utils.deepClone({\n                                        returnValues: this.getReturnDataFromResult(methodContext.result),\n                                        decoded: false,\n                                        reference: originalContractCallMethodContext.reference,\n                                        methodName: originalContractCallMethodContext.methodName,\n                                        methodParameters: originalContractCallMethodContext.methodParameters,\n                                        success: true,\n                                    }));\n                                }\n                            }\n                            returnObject.results[returnObjectResult.originalContractCallContext.reference] = returnObjectResult;\n                        }\n                        return [2 /*return*/, returnObject];\n                }\n            });\n        });\n    };\n    /**\n     * Get return data from result\n     * @param result The result\n     */\n    // tslint:disable-next-line: no-any\n    Multicall.prototype.getReturnDataFromResult = function (result) {\n        if (this._options.tryAggregate) {\n            return result.returnData;\n        }\n        return result;\n    };\n    /**\n     * Format return values so its always an array\n     * @param decodedReturnValues The decoded return values\n     */\n    // tslint:disable-next-line: no-any\n    Multicall.prototype.formatReturnValues = function (decodedReturnValues) {\n        var decodedReturnResults = decodedReturnValues;\n        if (decodedReturnValues.length === 1) {\n            decodedReturnResults = decodedReturnValues[0];\n        }\n        if (Array.isArray(decodedReturnResults)) {\n            return decodedReturnResults;\n        }\n        return [decodedReturnResults];\n    };\n    /**\n     * Build aggregate call context\n     * @param contractCallContexts The contract call contexts\n     */\n    Multicall.prototype.buildAggregateCallContext = function (contractCallContexts) {\n        var aggregateCallContext = [];\n        for (var contract = 0; contract < contractCallContexts.length; contract++) {\n            var contractContext = contractCallContexts[contract];\n            var executingInterface = new ethers.utils.Interface(JSON.stringify(contractContext.abi));\n            for (var method = 0; method < contractContext.calls.length; method++) {\n                // https://github.com/ethers-io/ethers.js/issues/211\n                var methodContext = contractContext.calls[method];\n                // tslint:disable-next-line: no-unused-expression\n                var encodedData = executingInterface.encodeFunctionData(methodContext.methodName, methodContext.methodParameters);\n                aggregateCallContext.push({\n                    contractContextIndex: Utils.deepClone(contract),\n                    contractMethodIndex: Utils.deepClone(method),\n                    target: contractContext.contractAddress,\n                    encodedData: encodedData,\n                });\n            }\n        }\n        return aggregateCallContext;\n    };\n    /**\n     * Find output types from abi\n     * @param abi The abi\n     * @param methodName The method name\n     */\n    Multicall.prototype.findOutputTypesFromAbi = function (abi, methodName) {\n        var _a;\n        var contract = new ethers.Contract(ethers.constants.AddressZero, abi);\n        methodName = methodName.trim();\n        if (contract.interface.functions[methodName]) {\n            return contract.interface.functions[methodName].outputs;\n        }\n        for (var i = 0; i < abi.length; i++) {\n            if (((_a = abi[i].name) === null || _a === void 0 ? void 0 : _a.trim()) === methodName) {\n                return abi[i].outputs;\n            }\n        }\n        return undefined;\n    };\n    /**\n     * Execute the multicall contract call\n     * @param calls The calls\n     */\n    Multicall.prototype.execute = function (calls, options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this._executionType;\n                        switch (_a) {\n                            case ExecutionType.web3: return [3 /*break*/, 1];\n                            case ExecutionType.ethers: return [3 /*break*/, 3];\n                            case ExecutionType.customHttp: return [3 /*break*/, 3];\n                        }\n                        return [3 /*break*/, 5];\n                    case 1: return [4 /*yield*/, this.executeWithWeb3(calls, options)];\n                    case 2: return [2 /*return*/, _b.sent()];\n                    case 3: return [4 /*yield*/, this.executeWithEthersOrCustom(calls, options)];\n                    case 4: return [2 /*return*/, _b.sent()];\n                    case 5: throw new Error(this._executionType + \" is not defined\");\n                }\n            });\n        });\n    };\n    /**\n     * Execute aggregate with web3 instance\n     * @param calls The calls context\n     */\n    Multicall.prototype.executeWithWeb3 = function (calls, options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var web3, networkId, contract, callParams, contractResponse, contractResponse;\n            var _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        web3 = this.getTypedOptions().web3Instance;\n                        return [4 /*yield*/, web3.eth.net.getId()];\n                    case 1:\n                        networkId = _c.sent();\n                        contract = new web3.eth.Contract(Multicall.ABI, this.getContractBasedOnNetwork(networkId));\n                        callParams = [];\n                        if (options.blockNumber) {\n                            callParams.push(options.blockNumber);\n                        }\n                        if (!this._options.tryAggregate) return [3 /*break*/, 3];\n                        return [4 /*yield*/, (_a = contract.methods\n                                .tryBlockAndAggregate(false, this.mapCallContextToMatchContractFormat(calls)))\n                                .call.apply(_a, callParams)];\n                    case 2:\n                        contractResponse = (_c.sent());\n                        contractResponse.blockNumber = BigNumber.from(contractResponse.blockNumber);\n                        return [2 /*return*/, this.buildUpAggregateResponse(contractResponse, calls)];\n                    case 3: return [4 /*yield*/, (_b = contract.methods\n                            .aggregate(this.mapCallContextToMatchContractFormat(calls)))\n                            .call.apply(_b, callParams)];\n                    case 4:\n                        contractResponse = (_c.sent());\n                        contractResponse.blockNumber = BigNumber.from(contractResponse.blockNumber);\n                        return [2 /*return*/, this.buildUpAggregateResponse(contractResponse, calls)];\n                }\n            });\n        });\n    };\n    /**\n     * Execute with ethers using passed in provider context or custom one\n     * @param calls The calls\n     */\n    Multicall.prototype.executeWithEthersOrCustom = function (calls, options) {\n        return __awaiter(this, void 0, void 0, function () {\n            var ethersProvider, customProvider, network, contract, overrideOptions, contractResponse, contractResponse;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        ethersProvider = this.getTypedOptions()\n                            .ethersProvider;\n                        if (!ethersProvider) {\n                            customProvider = this.getTypedOptions();\n                            if (customProvider.nodeUrl) {\n                                ethersProvider = new ethers.providers.JsonRpcProvider(customProvider.nodeUrl);\n                            }\n                            else {\n                                ethersProvider = ethers.getDefaultProvider();\n                            }\n                        }\n                        return [4 /*yield*/, ethersProvider.getNetwork()];\n                    case 1:\n                        network = _a.sent();\n                        contract = new ethers.Contract(this.getContractBasedOnNetwork(network.chainId), Multicall.ABI, ethersProvider);\n                        overrideOptions = {};\n                        if (options.blockNumber) {\n                            overrideOptions = __assign(__assign({}, overrideOptions), { blockTag: Number(options.blockNumber) });\n                        }\n                        if (!this._options.tryAggregate) return [3 /*break*/, 3];\n                        return [4 /*yield*/, contract.callStatic.tryBlockAndAggregate(false, this.mapCallContextToMatchContractFormat(calls), overrideOptions)];\n                    case 2:\n                        contractResponse = (_a.sent());\n                        return [2 /*return*/, this.buildUpAggregateResponse(contractResponse, calls)];\n                    case 3: return [4 /*yield*/, contract.callStatic.aggregate(this.mapCallContextToMatchContractFormat(calls), overrideOptions)];\n                    case 4:\n                        contractResponse = (_a.sent());\n                        return [2 /*return*/, this.buildUpAggregateResponse(contractResponse, calls)];\n                }\n            });\n        });\n    };\n    /**\n     * Build up the aggregated response from the contract response mapping\n     * metadata from the calls\n     * @param contractResponse The contract response\n     * @param calls The calls\n     */\n    Multicall.prototype.buildUpAggregateResponse = function (contractResponse, calls) {\n        var aggregateResponse = {\n            blockNumber: contractResponse.blockNumber.toNumber(),\n            results: [],\n        };\n        var _loop_1 = function (i) {\n            var existingResponse = aggregateResponse.results.find(function (c) { return c.contractContextIndex === calls[i].contractContextIndex; });\n            if (existingResponse) {\n                existingResponse.methodResults.push({\n                    result: contractResponse.returnData[i],\n                    contractMethodIndex: calls[i].contractMethodIndex,\n                });\n            }\n            else {\n                aggregateResponse.results.push({\n                    methodResults: [\n                        {\n                            result: contractResponse.returnData[i],\n                            contractMethodIndex: calls[i].contractMethodIndex,\n                        },\n                    ],\n                    contractContextIndex: calls[i].contractContextIndex,\n                });\n            }\n        };\n        for (var i = 0; i < contractResponse.returnData.length; i++) {\n            _loop_1(i);\n        }\n        return aggregateResponse;\n    };\n    /**\n     * Map call contract to match contract format\n     * @param calls The calls context\n     */\n    Multicall.prototype.mapCallContextToMatchContractFormat = function (calls) {\n        return calls.map(function (call) {\n            return {\n                target: call.target,\n                callData: call.encodedData,\n            };\n        });\n    };\n    /**\n     * Get typed options\n     */\n    Multicall.prototype.getTypedOptions = function () {\n        return this._options;\n    };\n    /**\n     * Get the contract based on the network\n     * @param tryAggregate The tryAggregate\n     * @param network The network\n     */\n    Multicall.prototype.getContractBasedOnNetwork = function (network) {\n        // if they have overriden the multicall custom contract address then use that\n        if (this._options.multicallCustomContractAddress) {\n            return this._options.multicallCustomContractAddress;\n        }\n        switch (network) {\n            case Networks.mainnet:\n            case Networks.ropsten:\n            case Networks.rinkeby:\n            case Networks.goerli:\n            case Networks.optimism:\n            case Networks.kovan:\n            case Networks.matic:\n            case Networks.kovanOptimism:\n            case Networks.xdai:\n            case Networks.goerliOptimism:\n            case Networks.arbitrum:\n            case Networks.rinkebyArbitrum:\n            case Networks.goerliArbitrum:\n            case Networks.mumbai:\n            case Networks.sepolia:\n            case Networks.avalancheMainnet:\n            case Networks.avalancheFuji:\n            case Networks.fantomTestnet:\n            case Networks.fantom:\n            case Networks.bsc:\n            case Networks.bsc_testnet:\n            case Networks.moonbeam:\n            case Networks.moonriver:\n            case Networks.moonbaseAlphaTestnet:\n            case Networks.harmony:\n            case Networks.cronos:\n            case Networks.fuse:\n            case Networks.songbirdCanaryNetwork:\n            case Networks.costonTestnet:\n            case Networks.boba:\n            case Networks.aurora:\n            case Networks.astar:\n            case Networks.okc:\n            case Networks.heco:\n            case Networks.metis:\n            case Networks.rsk:\n            case Networks.rskTestnet:\n            case Networks.evmos:\n            case Networks.evmosTestnet:\n            case Networks.thundercore:\n            case Networks.thundercoreTestnet:\n            case Networks.oasis:\n            case Networks.celo:\n            case Networks.godwoken:\n            case Networks.godwokentestnet:\n            case Networks.klatyn:\n            case Networks.milkomeda:\n            case Networks.kcc:\n                return '0xcA11bde05977b3631167028862bE2a173976CA11';\n            case Networks.etherlite:\n                return '0x21681750D7ddCB8d1240eD47338dC984f94AF2aC';\n            default:\n                throw new Error(\"Network - \" + network + \" doesn't have a multicall contract address defined. Please check your network or deploy your own contract on it.\");\n        }\n    };\n    // exposed as public as people can decide to use this outside multicall.call\n    Multicall.ABI = [\n        {\n            constant: false,\n            inputs: [\n                {\n                    components: [\n                        { name: 'target', type: 'address' },\n                        { name: 'callData', type: 'bytes' },\n                    ],\n                    name: 'calls',\n                    type: 'tuple[]',\n                },\n            ],\n            name: 'aggregate',\n            outputs: [\n                { name: 'blockNumber', type: 'uint256' },\n                { name: 'returnData', type: 'bytes[]' },\n            ],\n            payable: false,\n            stateMutability: 'nonpayable',\n            type: 'function',\n        },\n        {\n            inputs: [\n                {\n                    internalType: 'bool',\n                    name: 'requireSuccess',\n                    type: 'bool',\n                },\n                {\n                    components: [\n                        {\n                            internalType: 'address',\n                            name: 'target',\n                            type: 'address',\n                        },\n                        {\n                            internalType: 'bytes',\n                            name: 'callData',\n                            type: 'bytes',\n                        },\n                    ],\n                    internalType: 'struct Multicall2.Call[]',\n                    name: 'calls',\n                    type: 'tuple[]',\n                },\n            ],\n            name: 'tryBlockAndAggregate',\n            outputs: [\n                {\n                    internalType: 'uint256',\n                    name: 'blockNumber',\n                    type: 'uint256',\n                },\n                {\n                    internalType: 'bytes32',\n                    name: 'blockHash',\n                    type: 'bytes32',\n                },\n                {\n                    components: [\n                        {\n                            internalType: 'bool',\n                            name: 'success',\n                            type: 'bool',\n                        },\n                        {\n                            internalType: 'bytes',\n                            name: 'returnData',\n                            type: 'bytes',\n                        },\n                    ],\n                    internalType: 'struct Multicall2.Result[]',\n                    name: 'returnData',\n                    type: 'tuple[]',\n                },\n            ],\n            stateMutability: 'nonpayable',\n            type: 'function',\n        },\n    ];\n    return Multicall;\n}());\nexport { Multicall };\n"],"names":[],"sourceRoot":""}